# Компиляция в байт-код

Перед выполнением абстрактное синтаксическое дерево должно быть переведено в байт-код.
Он будет состоять из инструкций для стековой машины.

Этапы преобразования в байт-код:
1. Преобразовать имена и названия функций в числа
2. Рекурсивно сгенерировать байт-код для каждой функции
3. Склеить все вызовы в один файл
4. Произвести оптимизации байт-кода (опционально) или обфускацию
    может быть кто-нибудь захочет проприетарное ПО на рекурсивных функциях написать

Исполнитель состоит из двух стеков.
1. Стек вызовов функций и их аргументов (стек вызовов)
2. Стек расчёта значений, на котором выполняются операции (стек вычислений)

## Команды байт-кода
1. INCREMENT n - увеличить на 1 значение в n-й с конца ячейке стека вычислений.
2. DECREMENT n - уменьшить на 1 значение в n-й с конца ячейке стека вычислений.
3. JUMP_IF_ZERO n - посмотреть на последнее значение в стеке вычислений,
   если 0 - прыгнуть на строку с номером n,
   иначе - продолжить исполнение со следующей строки.
4. CALL_FUNCTION n m - вызывает функцию с номером n. При этом стек вызовов переносятся последние m значений из
   стека вычислений в обратном порядке (то есть из стека вычислений они убираются). 
   После этого вычисляется значение вызванной функции. Оно кладётся наверх стека вычислений,
   стек вызовов после этого возвращается к состоянию до вызова функции.
5. LOAD n - кладёт n-й с конца элемент в стеке вызовов наверх стека вычислений.
6. LOAD_CONST n - кладёт число n на стек вызовов.
7. RETURN - возвращает исполнение предыдущей функции, на стеке вычислений остаётся последнее значение на нём
   (то есть функция возвращает то, что лежит в конце этого стека в момент вызова RETURN)
8. POP - убирает последнее значение со стека вычислений
9. HALT - заканчивает исполнение программы. Последнее значение в стеке вычислений является результатом работы
   алгоритма.

## Пример байт-кода для рекурсивной функции add:
ADD:
1. LOAD 0
2. JUMP_IF_ZERO 8
3. DECREMENT 0
4. LOAD 1
5. CALL ADD
6. INCREMENT 0
7. RETURN
8. POP
9. PUSH_CONST 0
10. RETURN

При этом вычисление 2 + 2 будет выглядеть так:
1. LOAD_CONST 2
2. LOAD_CONST 2
3. CALL ADD
4. HALT

Здесь в вызовах CALL слово ADD будет заменено на номер функции.
Номер будет кодировать положение кода функции в общем файле.